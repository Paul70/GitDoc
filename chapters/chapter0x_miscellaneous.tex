\chapter{Miscellaneous}
\label{chapter:Miscellaneous}

\section{Setting VS Code as Default Git Editor}
\label{chapter:Miscellaneous.1}

VS Code is a very popular and handy editor. By editing git's global .config file it is possible to use VS Code as the default editor for writing 
new more verbose commits and to use it as git's merge and diff tool. The global .config file contains all important settings configuration parameter
like your e-mail address and your name which appears when you write a new commit, for example.
A display of this file is possible with
\begin{lstlisting}
	$\dollar$ git config --global -e
\end{lstlisting} 
The following steps are necessary to use VS Code as the default diff tool:
\begin{lstlisting}
	$\dollar$ git config --global diff.tool vscode
	$\dollar$ git config --global difftool.vscode.cmd 
	  'code --wait --diff $\dollar$LOCAL $\dollar$REMOTE'
\end{lstlisting}
For using VS Code as the default merge tool execute the next two commands:
\begin{lstlisting}
	$\dollar$ git config --global merge.tool vscode
	$\dollar$ git config --global difftool.vscode.cmd 'code --wait --diff $\dollar$MERGED'
\end{lstlisting}
Again, check your global .config file and see the changes made so for. Now your are able to use 
VS Code as your editor of choice. To also use it as the standard commit tool set it as the global editor in general by typing 
\begin{lstlisting}
	$\dollar$ git config --global core.editor "code --wait"
\end{lstlisting}
That's it! VS Code is now your overall git editor.


\section{Stashing}
\label{chapter:Miscellaneous.2}


\section{Submodules}
\label{chapter:Miscellaneous.3}

Briefly, you create a submodule in your main project when you add an additional library or some other file 
bundles which already represent a Git project, \ac{IE} have their own \verb|.git|-repository.
\\
Using submodules is most of the time straight forward. The official Git manual page is a good starting point 
to get the most important information, see \cite{Unknown2021Git-Tools-Submodule}.

At this point I just want to emphasize two things. The first one is, always initialize a newly added submodule
and and especially do this recursively if the submodule contains other submoduels itself:
\begin{lstlisting}
	$\dollar$ git submodule update --init
\end{lstlisting}  
or
\begin{lstlisting}
	$\dollar$ git submodule update --init --recursive
\end{lstlisting}
Omitting this step results in an empty submodule directory the next time your project gets cloned and the 
cloning operation delivers an error message, that it can not find one or more commits.

The second point is removing a submodule completely from your project which requires a few steps to go.

\usrStory{I want to remove the submodule library called "lib" completely from my project}
\begin{lstlisting}
	$\dollar$ git submodule deinit lib # deinitialize the submodule
	$\dollar$ git rm --cached demolibapp -r # remove from git
	$\dollar$ rm -rf .git/modules/lib	# delete the git-modules entry
	$\dollar$ git add --all
	$\dollar$ git commit -m "removing extra submodules"
	$\dollar$ git push
	$\dollar$ rm -rf lib # remove everything from the filesystem	
\end{lstlisting}



\section{The Benefits of having the Staging Area}
\label{chapter:Miscellaneous.4}

