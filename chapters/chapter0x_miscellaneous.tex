\chapter{Miscellaneous}
\label{chapter:Miscellaneous}

\section{Setting VS Code as Default Git Editor}
\label{chapter:Miscellaneous.1}

VS Code is a very popular and handy editor. By editing git's global .config file it is possible to use VS Code as the default editor for writing 
new more verbose commits and to use it as git's merge and diff tool. The global .config file contains all important settings configuration parameter
like your e-mail address and your name which appears when you write a new commit, for example.
A display of this file is possible with
\begin{lstlisting}
	$\dollar$ git config --global -e
\end{lstlisting} 
The following steps are necessary to use VS Code as the default diff tool:
\begin{lstlisting}
	$\dollar$ git config --global diff.tool vscode
	$\dollar$ git config --global difftool.vscode.cmd 
	  'code --wait --diff $\dollar$LOCAL $\dollar$REMOTE'
\end{lstlisting}
For using VS Code as the default merge tool execute the next two commands:
\begin{lstlisting}
	$\dollar$ git config --global merge.tool vscode
	$\dollar$ git config --global difftool.vscode.cmd 'code --wait --diff $\dollar$MERGED'
\end{lstlisting}
Again, check your global .config file and see the changes made so for. Now your are able to use 
VS Code as your editor of choice. To also use it as the standard commit tool set it as the global editor in general by typing 
\begin{lstlisting}
	$\dollar$ git config --global core.editor "code --wait"
\end{lstlisting}
That's it! VS Code is now your overall git editor.




\section{Stashing}
\label{chapter:Miscellaneous.2}

\subsection*{Git Stash-Motivation}

With the stash option Git enables the creation of patches representing work still in progress. Lets say you are currently 
working on branch A (not the master) but you shall fix a bug in branch B immediately. You normally would stage and commit 
your changes in branch A before switching to branch B. After committing and pushing the bug fix on branch B you return 
to branch A. Graphically, the situation is as follows (\cref{fig:StashSituation}):
\begin{figure}[H]
	\centering
	\input{tikz/stashSituation.tex}
	\caption{Stash Situation}
	\label{fig:StashSituation}
\end{figure}
However, at the time you stooped working on branch A, work was still in progress and commit A4 represents an incomplete 
state. Therefore you decide to cut off commit A4 and put your modifications back into the Working Tree:
\begin{lstlisting}
	$\dollar$ git reset --mixed HEAD~
\end{lstlisting} 
Now you can finish coding and create a commit representing a stable state of development on branch A.
This proceeding is perfectly fine but not the most intuitive way. A better approach would be to conserve 
the current state of branch A in a temporary, hidden commit which is not a direct part of the commit tree.
Git offers the \textbf{stashing mechanism} for exactly that purpose. 


Another motivation is that you did some hard work the whole and day and you want to save it in a commit like way.
Perhaps, the next day, you continue further with a critical section and there could be the situation where you 
want to switch back to the state of today. Creating a full commit is not what you want, since your work is not 
really complete and unclear for others who might check out your development branch. Again, a Git stash is what 
you need.

\subsection*{Git Stash-Usage}

Creating a stash is very easy. Just type 
\begin{lstlisting}
	$\dollar$ git stash
\end{lstlisting} 
That's it, the stash is now listed in the stash reflog and you can display all stashes of the current branch 
with 
\begin{lstlisting}
	$\dollar$ git stash list
\end{lstlisting} 
You can create as many stashes as you want in a row, the latest stash is referenced with zero, the next with one 
and so on.
If the stash description automatically generated by Git does not fit your needs, the option save enables user defined 
descriptions 
\begin{lstlisting}
	$\dollar$ git stash save <your descriptive text>
\end{lstlisting}
Sometimes, it is helpful to also put the un-tracked or even the ignored files into a stash because they are relevant 
for the current development process but not for the whole project. Git offers the options \verb|-u| or \verb|--include-untracked| and 
\verb|-a| or \verb|--all|, respectively:
\begin{lstlisting}
	$\dollar$ git stash -u 
	$\dollar$ git stash -a
\end{lstlisting}
Furthermore, you can keep all staged files in the index after creating a stash with
\begin{lstlisting} 
	$\dollar$ git stash --keep-index
\end{lstlisting}
This option is also combinable with other options, e.g.:
\begin{lstlisting} 
	$\dollar$ git stash -u --keep-index
\end{lstlisting}

There are two possibilities to recreate the state of your branch stored in a stash. The first one is pop, the second one
is apply. Using pop also removes the stash form the stashes reflog list whereas apply keeps the stash listed.
Not specifying explicitly a stash reference number always recreates stash number zero:
\begin{lstlisting}
	$\dollar$ git stash apply # recreate and keep stahs number 0 
	$\dollar$ git stash pop # recreate and remove stahs number 0
\end{lstlisting}
Older stashes need the reference number given through the list command:
\begin{lstlisting}
	$\dollar$ git stash pop/apply stash@{x}
\end{lstlisting}
Recreating a stash may lead to merge conflicts or which have to be solved using the merge tool:
\begin{lstlisting}
	$\dollar$ git merge tool 
\end{lstlisting}




\section{Submodules}
\label{chapter:Miscellaneous.3}

Briefly, you create a submodule in your main project when you add an additional library or some other file 
bundles which already represent a Git project, \ac{IE} have their own \verb|.git|-repository.
\\
Using submodules is most of the time straight forward. The official Git manual page is a good starting point 
to get the most important information, see \cite{Unknown2021Git-Tools-Submodule}.

At this point I just want to emphasize two things. The first one is, always initialize a newly added submodule
and and especially do this recursively if the submodule contains other submoduels itself:
\begin{lstlisting}
	$\dollar$ git submodule update --init
\end{lstlisting}  
or
\begin{lstlisting}
	$\dollar$ git submodule update --init --recursive
\end{lstlisting}
Omitting this step results in an empty submodule directory the next time your project gets cloned and the 
cloning operation delivers an error message, that it can not find one or more commits.

The second point is removing a submodule completely from your project which requires a few steps to go.

\usrStory{I want to remove the submodule library called "lib" completely from my project}
\begin{lstlisting}
	$\dollar$ git submodule deinit lib # deinitialize the submodule
	$\dollar$ git rm --cached demolibapp -r # remove from git
	$\dollar$ rm -rf .git/modules/lib	# delete the git-modules entry
	$\dollar$ git add --all
	$\dollar$ git commit -m "removing extra submodules"
	$\dollar$ git push
	$\dollar$ rm -rf lib # remove everything from the filesystem	
\end{lstlisting}



\section{Fetch, Pull and Rebase}
\label{chapter:Miscellaneous.4}

Git \verb*|fetch| command is used frequently by almost all Git users, however, not all users are always aware that they 
are using it. The reason is, that Git \verb*|pull| is actually a sequence of two other Git commands, Git \verb*|fetch|
first and Git \verb*|merge| second:

\hspace{2cm} \verb*|pull| = \verb*|fetch| + \verb*|merge|.

Let's have a closer look at what really happens when you pull new content from your remote repository. As stated above, 
a \verb*|pull| request consists of a \verb*|fetch| command in the first step. Fetching new commits means
\begin{itemize}
	\item downloading new commits from your remote.
	\item creating a new remote tracking branch consisting of these new commits rooted at the currently checked out 
	      commit (or the commit which is refereced by the HEAD pointer). This remote tracking branch is named 
	      \verb*|<remote_repo>/<remote_branch_name>|, e.g.\\ 
	      \verb*|origin/master| if you fetch new content from you remote
	      master/main branch.
\end{itemize} 
There are several ways to see this newly created remote tracking branch after a \verb*|fetch| command:
\begin{itemize}
	\item fetch new content verbously\\
	\begin{lstlisting}
		- $\dollar$ git fetch --verbose 
	\end{lstlisting}
	\item 
\end{itemize} 
\begin{lstlisting}
	- $\dollar$ git  
\end{lstlisting}
In a second step, this new branch is merged into the currently ckecked out branch. That's why you have to write a 
merge commit (message) when you pull from remote.
Maybe you are a little bit confused right now because you have done a lot of Git \verb*|pull| commands and never wrote 
a merge commit message nor does such a message exist in your Git log. The reason is, that you actually never did a pure 
Git \verb*|pull|, i.e. fetching and merging new commits. Probably, your Git \verb*|pull| command is modified slightly. 
This often happens, since merge commit meassages of remote tracking branches mess and blow up your git log. So people like
to modify their Git \verb*|pull| command to omit such messages by default (a lot of graphical Git clients modify Git in this way). 
The modification is, that Git by default does not execute a clean \verb*|pull| = \verb*|fetch|+\verb*|merge|. Instead, Git fetches new
commits and rebases them. In other words, Git does not merge the remote tracking branch created by fetch, it rebased it.
See the following example:


\begin{lstlisting}
	$\dollar$ git fetch <remote_repo_name> <local_branch_name> --verbose 
\end{lstlisting}
\begin{lstlisting}
	$\dollar$ git fetch origin master/main --verbose 
\end{lstlisting}


%\section{The Benefits of having the Staging Area}
%\label{chapter:Miscellaneous.4}

