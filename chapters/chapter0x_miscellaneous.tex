\chapter{Miscellaneous}
\label{chapter:Miscellaneous}

\section{Setting VS Code as Default Git Editor}
\label{chapter:Miscellaneous.1}

VS Code is a very popular and handy editor. By editing git's global .config file it is possible to use VS Code as the default editor for writing 
new more verbose commits and to use it as git's merge and diff tool. The global .config file contains all important settings configuration parameter
like your e-mail address and your name which appears when you write a new commit, for example.
A display of this file is possible with
\begin{lstlisting}
	$\dollar$ git config --global -e
\end{lstlisting} 
The following steps are necessary to use VS Code as the default diff tool:
\begin{lstlisting}
	$\dollar$ git config --global diff.tool vscode
	$\dollar$ git config --global difftool.vscode.cmd 
	  'code --wait --diff $\dollar$LOCAL $\dollar$REMOTE'
\end{lstlisting}
For using VS Code as the default merge tool execute the next two commands:
\begin{lstlisting}
	$\dollar$ git config --global merge.tool vscode
	$\dollar$ git config --global difftool.vscode.cmd 'code --wait --diff $\dollar$MERGED'
\end{lstlisting}
Again, check your global .config file and see the changes made so for. Now your are able to use 
VS Code as your editor of choice. To also use it as the standard commit tool set it as the global editor in general by typing 
\begin{lstlisting}
	$\dollar$ git config --global core.editor "code --wait"
\end{lstlisting}
That's it! VS Code is now your overall git editor.




\section{Stashing}
\label{chapter:Miscellaneous.2}

\subsection*{Git Stash-Motivation}

With the stash option Git enables the creation of patches representing work still in progress. Lets say you are currently 
working on branch A (not the master) but you shall fix a bug in branch B immediately. You normally would stage and commit 
your changes in branch A before switching to branch B. After committing and pushing the bug fix on branch B you return 
to branch A. Graphically, the situation is as follows (\cref{fig:StashSituation}):
\begin{figure}[H]
	\centering
	\input{tikz/stashSituation.tex}
	\caption{Stash Situation}
	\label{fig:StashSituation}
\end{figure}
However, at the time you stooped working on branch A, work was still in progress and commit A4 represents an incomplete 
state. Therefore you decide to cut off commit A4 and put your modifications back into the Working Tree:
\begin{lstlisting}
	$\dollar$ git reset --mixed HEAD~
\end{lstlisting} 
Now you can finish coding and create a commit representing a stable state of development on branch A.
This proceeding is perfectly fine but not the most intuitive way. A better approach would be to conserve 
the current state of branch A in a temporary, hidden commit which is not a direct part of the commit tree.
Git offers the \textbf{stashing mechanism} for exactly that purpose. 


Another motivation is that you did some hard work the whole and day and you want to save it in a commit like way.
Perhaps, the next day, you continue further with a critical section and there could be the situation where you 
want to switch back to the state of today. Creating a full commit is not what you want, since your work is not 
really complete and unclear for others who might check out your development branch. Again, a Git stash is what 
you need.

\subsection*{Git Stash-Usage}

Creating a stash is very easy. Just type 
\begin{lstlisting}
	$\dollar$ git stash
\end{lstlisting} 
That's it, the stash is now listed in the stash reflog and you can display all stashes of the current branch 
with 
\begin{lstlisting}
	$\dollar$ git stash list
\end{lstlisting} 
You can create as many stashes as you want in a row, the latest stash is referenced with zero, the next with one 
and so on.
If the stash description automatically generated by Git does not fit your needs, the option save enables user defined 
descriptions 
\begin{lstlisting}
	$\dollar$ git stash save <your descriptive text>
\end{lstlisting}
Sometimes, it is helpful to also put the un-tracked or even the ignored files into a stash because they are relevant 
for the current development process but not for the whole project. Git offers the options \verb|-u| or \verb|--include-untracked| and 
\verb|-a| or \verb|--all|, respectively:
\begin{lstlisting}
	$\dollar$ git stash -u 
	$\dollar$ git stash -a
\end{lstlisting}
Furthermore, you can keep all staged files in the index after creating a stash with
\begin{lstlisting} 
	$\dollar$ git stash --keep-index
\end{lstlisting}
This option is also combinable with other options, e.g.:
\begin{lstlisting} 
	$\dollar$ git stash -u --keep-index
\end{lstlisting}

There are two possibilities to recreate the state of your branch stored in a stash. The first one is pop, the second one
is apply. Using pop also removes the stash form the stashes reflog list whereas apply keeps the stash listed.
Not specifying explicitly a stash reference number always recreates stash number zero:
\begin{lstlisting}
	$\dollar$ git stash apply # recreate and keep stahs number 0 
	$\dollar$ git stash pop # recreate and remove stahs number 0
\end{lstlisting}
Older stashes need the reference number given through the list command:
\begin{lstlisting}
	$\dollar$ git stash pop/apply stash@{x}
\end{lstlisting}
Recreating a stash may lead to merge conflicts or which have to be solved using the merge tool:
\begin{lstlisting}
	$\dollar$ git merge tool 
\end{lstlisting}




\section{Submodules}
\label{chapter:Miscellaneous.3}

Briefly, you create a submodule in your main project when you add an additional library or some other file 
bundles which already represent a Git project, \ac{IE} have their own \verb|.git|-repository.
\\
Using submodules is most of the time straight forward. The official Git manual page is a good starting point 
to get the most important information, see \cite{Unknown2021Git-Tools-Submodule}.

At this point I just want to emphasize two things. The first one is, always initialize a newly added submodule
and and especially do this recursively if the submodule contains other submoduels itself:
\begin{lstlisting}
	$\dollar$ git submodule update --init
\end{lstlisting}  
or
\begin{lstlisting}
	$\dollar$ git submodule update --init --recursive
\end{lstlisting}
Omitting this step results in an empty submodule directory the next time your project gets cloned and the 
cloning operation delivers an error message, that it can not find one or more commits.

The second point is removing a submodule completely from your project which requires a few steps to go.

\usrStory{I want to remove the submodule library called "lib" completely from my project}
\begin{lstlisting}
	$\dollar$ git submodule deinit lib # deinitialize the submodule
	$\dollar$ git rm --cached demolibapp -r # remove from git
	$\dollar$ rm -rf .git/modules/lib	# delete the git-modules entry
	$\dollar$ git add --all
	$\dollar$ git commit -m "removing extra submodules"
	$\dollar$ git push
	$\dollar$ rm -rf lib # remove everything from the filesystem	
\end{lstlisting}



%\section{The Benefits of having the Staging Area}
%\label{chapter:Miscellaneous.4}

